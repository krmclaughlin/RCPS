# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Internal function to check if the observed recruitment tree is returned by any
#'   given Ustar and Vstar matrices.
#'
#' @param Ustar Matrix of utilities from recruiters to peers.
#' @param Vstar Matrix of utilities from peers to recruiters.
#' @param netstage Amended adjacency matrix, with observed recruitment information.
#' @param recfromUV3urR Call to another \code{C++} function.
#' @param reslocal Logical: use additional information about the underlying network?
#'    Makes computation faster. If TRUE, assumes that \code{netstage} takes three values:
#'    1 indicates a recruitment tie (and thus a tie in the underlying network); 0 indicates
#'    no recruitment tie, but a tie does exist in the underlying network; NA indicates no
#'    tie in the underlying network, and thus no possibility of recruitment.
#'
#' @return TRUE or FALSE if the given Ustar and Vstar return the observed recruitment tree.
checkutilC <- function(Ustar, Vstar, netstage, recfromUV3urR, reslocal) {
    .Call(`_RCPS_checkutilC`, Ustar, Vstar, netstage, recfromUV3urR, reslocal)
}

concat <- function(vec1, vec2) {
    .Call(`_RCPS_concat`, vec1, vec2)
}

Uab1 <- function(i, j, adjmat, U, V) {
    .Call(`_RCPS_Uab1`, i, j, adjmat, U, V)
}

Vab1 <- function(i, j, adjmat, U, V) {
    .Call(`_RCPS_Vab1`, i, j, adjmat, U, V)
}

Uab2 <- function(i, j, adjmat, U, V) {
    .Call(`_RCPS_Uab2`, i, j, adjmat, U, V)
}

Vab2 <- function(i, j, adjmat, U, V) {
    .Call(`_RCPS_Vab2`, i, j, adjmat, U, V)
}

Uab3 <- function(i, j, adjmat, U, V) {
    .Call(`_RCPS_Uab3`, i, j, adjmat, U, V)
}

Uab4 <- function(i, j, adjmat, U, V) {
    .Call(`_RCPS_Uab4`, i, j, adjmat, U, V)
}

Vab5 <- function(i, j, adjmat, U, V) {
    .Call(`_RCPS_Vab5`, i, j, adjmat, U, V)
}

Vab6 <- function(i, j, adjmat, U, V) {
    .Call(`_RCPS_Vab6`, i, j, adjmat, U, V)
}

#' Internal funcion to construct U given alpha, X, epsilon
#'
#' Note that this is the CALCULATION, only used in step 0
#'
#' @param charrec Matrix of covariate values for recruiters.
#' @param charpeer Matrix of covariate values for peers.
#' @param alpha Preference coefficients for recruiters to peers.
#' @param ksi Parameter for number of recruits. Vector length ncoupon.
#' @param epsilon Matrix with random error.  Must have same dimension as U.
#'
#' @return Matrix with calculated values of \eqn{U}, where \eqn{U =\alpha X + \epsilon}
makeU <- function(charrec, charpeer, alpha, ksi, epsilon) {
    .Call(`_RCPS_makeU`, charrec, charpeer, alpha, ksi, epsilon)
}

#' Internal funcion to construct V given beta, Y, gamma
#'
#' Note that this is the CALCULATION, only used in step 0
#'
#' @param charrec Matrix of covariate values for recruiters.
#' @param charpeer Matrix of covariate values for peers.
#' @param beta Preference coefficients for peers to recruiters. Last value is self.
#' @param zeta Parameter for self match. Vector length 1.
#' @param gamma Matrix with random error.  Must have same dimension as V.
#'
#' @return Matrix with calculated values of \eqn{V}, where \eqn{V =\beta Y + \gamma}
makeV <- function(charrec, charpeer, beta, zeta, gamma) {
    .Call(`_RCPS_makeV`, charrec, charpeer, beta, zeta, gamma)
}

makeEL <- function(adjmat, sindex, pindex, w) {
    .Call(`_RCPS_makeEL`, adjmat, sindex, pindex, w)
}

getType <- function(i, j, adjmat, U, V) {
    .Call(`_RCPS_getType`, i, j, adjmat, U, V)
}

newUijC <- function(i, j, adjmat, U, V, alpha, Xij, rtruncnorm) {
    .Call(`_RCPS_newUijC`, i, j, adjmat, U, V, alpha, Xij, rtruncnorm)
}

newVjiC <- function(i, j, adjmat, U, V, beta, Yji, rtruncnorm) {
    .Call(`_RCPS_newVjiC`, i, j, adjmat, U, V, beta, Yji, rtruncnorm)
}

#' Internal (cpp) function for the Gibbs sampler iterations.
#'
#' Setup must already have occurred.
#'
#' @param Kcalc The number of iterations to run.  Equal to desired number
#'   of draws times interval, plus the burn-in period.
#' @param alphastart Initialization value for alpha, preference coefficient for recruiters.
#' @param betastart Initialization value for beta, preference coefficient for peers.
#' @param adjmat List of amended adjacency matrices, one for each wave.  Each contains
#'   recruitment information for this wave plus information about self-matches. Assumed to
#'   take two values (0-1) if \code{restrict.local=FALSE}, or three values (0-1-NA) if
#'   \code{restrict.local=TRUE}.
#' @param nrec List of number of recruiters, one value for each wave.
#' @param npeer List of number of peers, one value for each wave.
#' @param X List of list of covariate(s) matches from recruiters to peers.
#' @param Y List of list of covariate(s) matches from peers to recruiters.
#' @param Ustar List of matrices of utilities from recruiters to peers, one for each wave.
#' @param Vstar List of matrices of utilities from peers to recruiters, one for each wave.
#' @param expgrid R function \code{expand.grid} from \code{base}.
#' @param rtruncnorm R function \code{rtruncnorm} from the \code{truncnorm} package.
#' @param sample R function \code{sample} from \code{base}.
#' @param ma0 Prior value \eqn{\mu_\alpha}, mean of normal distribution for alpha.
#' @param sa0 Prior value \eqn{\Sigma_\alpha}, variance of normal distribution for alpha.
#' @param mb0 Prior value \eqn{\mu_\beta}, mean of normal distribution for beta.
#' @param sb0 Prior value \eqn{\Sigma_\beta}, varaince of normal distribution for beta.
#' @param tallowed Number of hours allowed on Hoffman.
#' @param recfromUV3urR R function in this package.
#' @param reslocal Logical: use additional information about the underlying network? Makes
#'   computation faster. If TRUE, assumes that \code{netstage} takes three values: 1 indicates a
#'   recruitment tie (and thus a tie in the underlying network); 0 indicates no recruitment tie,
#'   but a tie does exist in the underlying network; NA indicates no tie in the underlying network,
#'   and thus no possibility of recruitment.
#' @param mvrnorm Function to make multivariate normal draws.
#' @param updlast Logical: flag to stop. Not currently used.
#'
#' @return A list containing
#'   \item{alpha}{Draws of alpha from the posterior distribution.}
#'   \item{beta}{Draws of beta from the posterior distribution.}
#'   \item{rejcounter}{Number of rejections (bc of swapping problem).}
#'   \item{earlystop}{Number of iterations after which Gibbs sampler was forced to abort for time constraints.}
gibbsC <- function(Kcalc, alphastart, betastart, adjmat, nrec, npeer, X, Y, Ustar, Vstar, expgrid, rtruncnorm, sample, ma0, sa0, mb0, sb0, tallowed, recfromUV3urR, reslocal, mvrnorm, updlast) {
    .Call(`_RCPS_gibbsC`, Kcalc, alphastart, betastart, adjmat, nrec, npeer, X, Y, Ustar, Vstar, expgrid, rtruncnorm, sample, ma0, sa0, mb0, sb0, tallowed, recfromUV3urR, reslocal, mvrnorm, updlast)
}

makeNetstageC <- function(netstage, recvec, peervec) {
    .Call(`_RCPS_makeNetstageC`, netstage, recvec, peervec)
}

whichCone <- function(x, val) {
    .Call(`_RCPS_whichCone`, x, val)
}

maxintNoNA <- function(x) {
    .Call(`_RCPS_maxintNoNA`, x)
}

recfromUV3urC <- function(Urank, Vrank, reslocal) {
    .Call(`_RCPS_recfromUV3urC`, Urank, Vrank, reslocal)
}

#' Internal (cpp) of matching function: peer choices.
#'
#' For each peer, returns their choice from amongst the recruiters
#'   that selected them at this stage and themself. Will always return
#'   a value (self), even if not selected.
#'
#' @param recsels List with the (up to 3) selections of each recruiter.
#' @param Vrank matrix of ranks from each peer to each recruiter and self.
#'
#' @return A vector with the index of each peer's choice.
peerChoice <- function(recsels, Vrank) {
    .Call(`_RCPS_peerChoice`, recsels, Vrank)
}

#' Internal (cpp) of matching function: housekeeping.
#'
#' Function that carries out list reassignment: takes the vector of peer
#'   choices at a given stage of matching and makes a new selection list.
#'
#' @param nrec Number of recruiters.
#' @param npeer Number of peers.
#' @param jchoice Vector of length \code{npeer} with each peer's selection
#'   (can be self).
#' @param RS List.
#'
#' @return A list with the new recruiter selections.
listReassign <- function(nrec, npeer, jchoice, RS) {
    .Call(`_RCPS_listReassign`, nrec, npeer, jchoice, RS)
}

#' Internal (cpp) of matching function: finds first zero in a vector.
#'
#' @param x An integer vector.
#'
#' @return Position in vector (R-vector; cannot be 0) where first zero occurs.
#'   Returns 0 if there are no zeros.
firstZero <- function(x) {
    .Call(`_RCPS_firstZero`, x)
}

makeX <- function(charrec, charpeer, netstage) {
    .Call(`_RCPS_makeX`, charrec, charpeer, netstage)
}

makeY <- function(charrec, charpeer, netstage) {
    .Call(`_RCPS_makeY`, charrec, charpeer, netstage)
}

calcU <- function(alpha, X, epsilon) {
    .Call(`_RCPS_calcU`, alpha, X, epsilon)
}

calcV <- function(beta, Y, gamma) {
    .Call(`_RCPS_calcV`, beta, Y, gamma)
}

ipNoSelf <- function(vec1, vec2) {
    .Call(`_RCPS_ipNoSelf`, vec1, vec2)
}

ipSelf <- function(vec1, vec2) {
    .Call(`_RCPS_ipSelf`, vec1, vec2)
}

alphaFromU <- function(X, U, ma0, sa0, mvrnorm) {
    .Call(`_RCPS_alphaFromU`, X, U, ma0, sa0, mvrnorm)
}

betaFromV <- function(Y, V, mb0, sb0, mvrnorm) {
    .Call(`_RCPS_betaFromV`, Y, V, mb0, sb0, mvrnorm)
}

whichC <- function(x, val) {
    .Call(`_RCPS_whichC`, x, val)
}

optsetU <- function(i, j, adjmat, U, V) {
    .Call(`_RCPS_optsetU`, i, j, adjmat, U, V)
}

optsetV <- function(i, j, adjmat, U, V) {
    .Call(`_RCPS_optsetV`, i, j, adjmat, U, V)
}

